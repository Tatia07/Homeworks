# აირჩიე Heap, Merge და Shell sort_იდან ერთ-ერთი. მოიძიე ინტერნეტში შესაბამისი კოდი, გაუშვი შენს ფაილში და გაარჩიე. 
# კოდის ყოველ მნიშვნელოვან ნაწილს დაუწერე ქართულად კომენტარი, რომელშიც ახსნი რა ხდება ამ მომენტში და გამოაგზავნე.

# Merge Sort

# შექმნილია რეკურსიული ფუნქცია merge_sort, რომელსაც პარამეტრად გადაეცემა სია arr. შემდეგ ეს ფუნქცია ამოწმებს გადაცემული სიის სიგრძეს(ნაკლებია ან ტოლია 1-ზე თუ არა).
# თუ ეს სია ცარიელია ან მხოლოდ ერთ ელემენტს შეიცავს, შესაბამისად უკვე დალაგებულია და პირდაპირ ამ სიას აბრუნებს. 
def merge_sort(arr):
    if len(arr) <= 1:
        return arr

# თუ არადა, სიას ყოფს ორ ნაწილად, left_half-ად და right_half-ად. middle იქნება სიის სიგრძე გაყოფილი ორზე, შესაბამისად left_half იქნება პირველი 
# ელემენტიდან ამ middle ელემენტამდე, და right_half იქნება ელემენტები middle ელემენტის შემდეგ.(slicing მეთოდი)
    middle = len(arr) // 2
    left_half = arr[:middle]
    right_half = arr[middle:]

# რეკურსიულად დავალაგებთ ორივე სიას
    left_half = merge_sort(left_half)
    right_half = merge_sort(right_half)

# და გავაერთიანებთ უკვე დალაგებულ სიებს. (merge ფუნქციის გამოყენებით)
    return merge(left_half, right_half)

# გვაქვს მეორე ფუნქცია merge, რომელსაც ორი დასორტირებული სია გადაეცემა, left და right, და აერთიანებს მათ ერთ დალაგებულ სიაში. 
# merge ფუნქციაში არის ცარიელი სია, რომელსაც ქვია result, და აქ შეინახება გაერთიანებული და დალაგებული ელემენტები left და right სიებიდან. ასევე გვაქვს ორი ინდექსის ცვლადი, 
# left_index და right_index, რომ თვალყური ადევნოს სად ვართ მარცხენა და მარჯვენა სიებში ელემენტების შედარებისას და გაერთიანებისას. 
def merge(left, right):
    result = []
    left_index, right_index = 0, 0

# შემდეგ გვაქვს While loop, სადაც ვადარებთ left-ის და right-ის ელემენტებს მანამ, სანამ left_index left-ის სიგრძეზე ნაკლებია და right_index right-ზე. 
# თუ left სიაში კონკრეტულ ადგილზე მყოფი ელემენტი ნაკლებია right სიაში იგივე ადგილზე მყოფ ელემენტზე, მაშინ result სიაში ჩაამატებს. და ერთით იზრდება, შემდეგ ელემენტზე გადადის და იგივეს იმეორებს. 
    while left_index < len(left) and right_index < len(right):
        if left[left_index] < right[right_index]:
            result.append(left[left_index])
            left_index += 1
# სხვა შემთხვევაში გამოდის, რომ right უფრო პატარა ყოფილა და მას ჩასვამს სიაში. და მასაც გაზრდის ერთით
        else:
            result.append(right[right_index])
            right_index += 1
#ერთ-ერთი სიის სრულად დამუშავების შემდეგ, მეორე სიაში შეიძლება დარჩენილი იყოს ელემენტები. ფუნქცია ამატებს ამ დარჩენილ ელემენტებს შედეგების სიაში.
    result.extend(left[left_index:])
    result.extend(right[right_index:])
# და აბრუნებს result სიას
    return result

# გამოყენების მაგალითი:
# შევქმნით ცვლადს სახელად sorted_list, და merge_sort ფუნქციაში პარამეტრად გავატანთ my_list-ს. შედეგს დავპრინტავთ და მივიღებთ merge sort ით დალაგებულ სიას. 
my_list = [38, 27, 43, 3, 9, 82, 10]
sorted_list = merge_sort(my_list)
print(sorted_list)
